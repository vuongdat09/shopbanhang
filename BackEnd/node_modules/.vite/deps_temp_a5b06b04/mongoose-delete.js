import {
  require_util
} from "./chunk-F5CRJ3S6.js";
import {
  require_browser_umd
} from "./chunk-3ENYJDLB.js";
import {
  __commonJS
} from "./chunk-7FP5O474.js";

// node_modules/mongoose-delete/index.js
var require_mongoose_delete = __commonJS({
  "node_modules/mongoose-delete/index.js"(exports, module) {
    var mongoose = require_browser_umd();
    var Schema = mongoose.Schema;
    var Model = mongoose.Model;
    var util = require_util();
    function parseUpdateArguments(conditions, doc, options, callback) {
      if ("function" === typeof options) {
        callback = options;
        options = null;
      } else if ("function" === typeof doc) {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if ("function" === typeof conditions) {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      var args = [];
      if (conditions)
        args.push(conditions);
      if (doc)
        args.push(doc);
      if (options)
        args.push(options);
      if (callback)
        args.push(callback);
      return args;
    }
    function parseIndexFields(options) {
      var indexFields = {
        deleted: false,
        deletedAt: false,
        deletedBy: false
      };
      if (!options.indexFields) {
        return indexFields;
      }
      if ((typeof options.indexFields === "string" || options.indexFields instanceof String) && options.indexFields === "all") {
        indexFields.deleted = indexFields.deletedAt = indexFields.deletedBy = true;
      }
      if (typeof options.indexFields === "boolean" && options.indexFields === true) {
        indexFields.deleted = indexFields.deletedAt = indexFields.deletedBy = true;
      }
      if (Array.isArray(options.indexFields)) {
        indexFields.deleted = options.indexFields.indexOf("deleted") > -1;
        indexFields.deletedAt = options.indexFields.indexOf("deletedAt") > -1;
        indexFields.deletedBy = options.indexFields.indexOf("deletedBy") > -1;
      }
      return indexFields;
    }
    function createSchemaObject(typeKey, typeValue, options) {
      options[typeKey] = typeValue;
      return options;
    }
    module.exports = function(schema, options) {
      options = options || {};
      var indexFields = parseIndexFields(options);
      var typeKey = schema.options.typeKey;
      var mongooseMajorVersion = +mongoose.version[0];
      var mainUpdateMethod = mongooseMajorVersion < 5 ? "update" : "updateMany";
      var mainUpdateWithDeletedMethod = mainUpdateMethod + "WithDeleted";
      function updateDocumentsByQuery(schema2, conditions, updateQuery, callback) {
        if (schema2[mainUpdateWithDeletedMethod]) {
          return schema2[mainUpdateWithDeletedMethod](conditions, updateQuery, { multi: true }, callback);
        } else {
          return schema2[mainUpdateMethod](conditions, updateQuery, { multi: true }, callback);
        }
      }
      schema.add({ deleted: createSchemaObject(typeKey, Boolean, { default: false, index: indexFields.deleted }) });
      if (options.deletedAt === true) {
        schema.add({ deletedAt: createSchemaObject(typeKey, Date, { index: indexFields.deletedAt }) });
      }
      if (options.deletedBy === true) {
        schema.add({ deletedBy: createSchemaObject(typeKey, options.deletedByType || Schema.Types.ObjectId, { index: indexFields.deletedBy }) });
      }
      var use$neOperator = true;
      if (options.use$neOperator !== void 0 && typeof options.use$neOperator === "boolean") {
        use$neOperator = options.use$neOperator;
      }
      schema.pre("save", function(next) {
        if (!this.deleted) {
          this.deleted = false;
        }
        next();
      });
      if (options.overrideMethods) {
        var overrideItems = options.overrideMethods;
        var overridableMethods = ["count", "countDocuments", "find", "findOne", "findOneAndUpdate", "update", "updateOne", "updateMany", "aggregate"];
        var finalList = [];
        if ((typeof overrideItems === "string" || overrideItems instanceof String) && overrideItems === "all") {
          finalList = overridableMethods;
        }
        if (typeof overrideItems === "boolean" && overrideItems === true) {
          finalList = overridableMethods;
        }
        if (Array.isArray(overrideItems)) {
          overrideItems.forEach(function(method) {
            if (overridableMethods.indexOf(method) > -1) {
              finalList.push(method);
            }
          });
        }
        if (finalList.indexOf("aggregate") > -1) {
          schema.pre("aggregate", function() {
            var _a, _b, _c;
            var firstMatch = this.pipeline()[0];
            if (((_b = (_a = firstMatch.$match) == null ? void 0 : _a.deleted) == null ? void 0 : _b.$ne) !== false) {
              if (((_c = firstMatch.$match) == null ? void 0 : _c.showAllDocuments) === "true") {
                var { showAllDocuments, ...replacement } = firstMatch.$match;
                this.pipeline().shift();
                if (Object.keys(replacement).length > 0) {
                  this.pipeline().unshift({ $match: replacement });
                }
              } else {
                this.pipeline().unshift({ $match: { deleted: { "$ne": true } } });
              }
            }
          });
        }
        finalList.forEach(function(method) {
          if (["count", "countDocuments", "find", "findOne"].indexOf(method) > -1) {
            var modelMethodName = method;
            if (mongooseMajorVersion < 5 && method === "countDocuments" && typeof Model.countDocuments !== "function") {
              modelMethodName = "count";
            }
            schema.statics[method] = function() {
              var query = Model[modelMethodName].apply(this, arguments);
              if (!arguments[2] || arguments[2].withDeleted !== true) {
                if (use$neOperator) {
                  query.where("deleted").ne(true);
                } else {
                  query.where({ deleted: false });
                }
              }
              return query;
            };
            schema.statics[method + "Deleted"] = function() {
              if (use$neOperator) {
                return Model[modelMethodName].apply(this, arguments).where("deleted").ne(false);
              } else {
                return Model[modelMethodName].apply(this, arguments).where({ deleted: true });
              }
            };
            schema.statics[method + "WithDeleted"] = function() {
              return Model[modelMethodName].apply(this, arguments);
            };
          } else {
            if (method === "aggregate") {
              schema.statics[method + "Deleted"] = function() {
                var args = [];
                Array.prototype.push.apply(args, arguments);
                var match = { $match: { deleted: { "$ne": false } } };
                arguments.length ? args[0].unshift(match) : args.push([match]);
                return Model[method].apply(this, args);
              };
              schema.statics[method + "WithDeleted"] = function() {
                var args = [];
                Array.prototype.push.apply(args, arguments);
                var match = { $match: { showAllDocuments: "true" } };
                arguments.length ? args[0].unshift(match) : args.push([match]);
                return Model[method].apply(this, args);
              };
            } else {
              schema.statics[method] = function() {
                var args = parseUpdateArguments.apply(void 0, arguments);
                if (use$neOperator) {
                  args[0].deleted = { "$ne": true };
                } else {
                  args[0].deleted = false;
                }
                return Model[method].apply(this, args);
              };
              schema.statics[method + "Deleted"] = function() {
                var args = parseUpdateArguments.apply(void 0, arguments);
                if (use$neOperator) {
                  args[0].deleted = { "$ne": false };
                } else {
                  args[0].deleted = true;
                }
                return Model[method].apply(this, args);
              };
              schema.statics[method + "WithDeleted"] = function() {
                return Model[method].apply(this, arguments);
              };
            }
          }
        });
      }
      schema.methods.delete = function(deletedBy, cb) {
        if (typeof deletedBy === "function") {
          cb = deletedBy;
          deletedBy = null;
        }
        this.deleted = true;
        if (schema.path("deletedAt")) {
          this.deletedAt = /* @__PURE__ */ new Date();
        }
        if (schema.path("deletedBy")) {
          this.deletedBy = deletedBy;
        }
        if (options.validateBeforeDelete === false) {
          return this.save({ validateBeforeSave: false }, cb);
        }
        return this.save(cb);
      };
      schema.statics.delete = function(conditions, deletedBy, callback) {
        if (typeof deletedBy === "function") {
          callback = deletedBy;
          conditions = conditions;
          deletedBy = null;
        } else if (typeof conditions === "function") {
          callback = conditions;
          conditions = {};
          deletedBy = null;
        }
        var doc = {
          deleted: true
        };
        if (schema.path("deletedAt")) {
          doc.deletedAt = /* @__PURE__ */ new Date();
        }
        if (schema.path("deletedBy")) {
          doc.deletedBy = deletedBy;
        }
        return updateDocumentsByQuery(this, conditions, doc, callback);
      };
      schema.statics.deleteById = function(id, deletedBy, callback) {
        if (arguments.length === 0 || typeof id === "function") {
          var msg = "First argument is mandatory and must not be a function.";
          throw new TypeError(msg);
        }
        var conditions = {
          _id: id
        };
        return this.delete(conditions, deletedBy, callback);
      };
      schema.methods.restore = function(callback) {
        this.deleted = false;
        this.deletedAt = void 0;
        this.deletedBy = void 0;
        if (options.validateBeforeRestore === false) {
          return this.save({ validateBeforeSave: false }, callback);
        }
        return this.save(callback);
      };
      schema.statics.restore = function(conditions, callback) {
        if (typeof conditions === "function") {
          callback = conditions;
          conditions = {};
        }
        var doc = {
          $unset: {
            deleted: true,
            deletedAt: true,
            deletedBy: true
          }
        };
        return updateDocumentsByQuery(this, conditions, doc, callback);
      };
    };
  }
});
export default require_mongoose_delete();
//# sourceMappingURL=mongoose-delete.js.map
